/* tslint:disable */
/* eslint-disable */
/**
 * PMM API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: public
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    InlineObject,
    InlineObjectFromJSON,
    InlineObjectToJSON,
    InlineObject1,
    InlineObject1FromJSON,
    InlineObject1ToJSON,
    InlineObject2,
    InlineObject2FromJSON,
    InlineObject2ToJSON,
    InlineObject3,
    InlineObject3FromJSON,
    InlineObject3ToJSON,
    InlineResponse200,
    InlineResponse200FromJSON,
    InlineResponse200ToJSON,
    InlineResponse2001,
    InlineResponse2001FromJSON,
    InlineResponse2001ToJSON,
    InlineResponse2002,
    InlineResponse2002FromJSON,
    InlineResponse2002ToJSON,
    InlineResponse2003,
    InlineResponse2003FromJSON,
    InlineResponse2003ToJSON,
    InlineResponse20042,
    InlineResponse20042FromJSON,
    InlineResponse20042ToJSON,
    InlineResponseDefault,
    InlineResponseDefaultFromJSON,
    InlineResponseDefaultToJSON,
    InlineResponseDefault1,
    InlineResponseDefault1FromJSON,
    InlineResponseDefault1ToJSON,
} from '../models';

export interface AWSInstanceCheckRequest {
    body: InlineObject;
}

export interface ChangeSettingsRequest {
    body: InlineObject1;
}

export interface CheckUpdatesRequest {
    body: InlineObject2;
}

export interface GetSettingsRequest {
    body: object;
}

export interface StartUpdateRequest {
    body: object;
}

export interface UpdateStatusRequest {
    body: InlineObject3;
}

export interface VersionRequest {
    dummy?: string;
}

/**
 * 
 */
export class ServerApi extends runtime.BaseAPI {

    /**
     * AWSInstanceCheck checks AWS EC2 instance ID.
     */
    async aWSInstanceCheckRaw(requestParameters: AWSInstanceCheckRequest): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling aWSInstanceCheck.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/AWSInstanceCheck`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: InlineObjectToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * AWSInstanceCheck checks AWS EC2 instance ID.
     */
    async aWSInstanceCheck(requestParameters: AWSInstanceCheckRequest): Promise<object> {
        const response = await this.aWSInstanceCheckRaw(requestParameters);
        return await response.value();
    }

    /**
     * ChangeSettings changes PMM Server settings.
     */
    async changeSettingsRaw(requestParameters: ChangeSettingsRequest): Promise<runtime.ApiResponse<InlineResponse200>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling changeSettings.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/Settings/Change`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: InlineObject1ToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse200FromJSON(jsonValue));
    }

    /**
     * ChangeSettings changes PMM Server settings.
     */
    async changeSettings(requestParameters: ChangeSettingsRequest): Promise<InlineResponse200> {
        const response = await this.changeSettingsRaw(requestParameters);
        return await response.value();
    }

    /**
     * CheckUpdates checks PMM Server updates availability.
     */
    async checkUpdatesRaw(requestParameters: CheckUpdatesRequest): Promise<runtime.ApiResponse<InlineResponse2001>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling checkUpdates.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/Updates/Check`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: InlineObject2ToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2001FromJSON(jsonValue));
    }

    /**
     * CheckUpdates checks PMM Server updates availability.
     */
    async checkUpdates(requestParameters: CheckUpdatesRequest): Promise<InlineResponse2001> {
        const response = await this.checkUpdatesRaw(requestParameters);
        return await response.value();
    }

    /**
     * GetSettings returns current PMM Server settings.
     */
    async getSettingsRaw(requestParameters: GetSettingsRequest): Promise<runtime.ApiResponse<InlineResponse200>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling getSettings.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/Settings/Get`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse200FromJSON(jsonValue));
    }

    /**
     * GetSettings returns current PMM Server settings.
     */
    async getSettings(requestParameters: GetSettingsRequest): Promise<InlineResponse200> {
        const response = await this.getSettingsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Logs returns logs of the PMM-Server.
     */
    async logsRaw(): Promise<runtime.ApiResponse<Blob>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/logs.zip`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Logs returns logs of the PMM-Server.
     */
    async logs(): Promise<Blob> {
        const response = await this.logsRaw();
        return await response.value();
    }

    /**
     * Readiness returns an error when some PMM Server component is not ready yet or is being restarted. It can be used as for Docker health check or Kubernetes readiness probe.
     */
    async readinessRaw(): Promise<runtime.ApiResponse<object>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/readyz`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Readiness returns an error when some PMM Server component is not ready yet or is being restarted. It can be used as for Docker health check or Kubernetes readiness probe.
     */
    async readiness(): Promise<object> {
        const response = await this.readinessRaw();
        return await response.value();
    }

    /**
     * StartUpdate starts PMM Server update.
     */
    async startUpdateRaw(requestParameters: StartUpdateRequest): Promise<runtime.ApiResponse<InlineResponse2002>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling startUpdate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/Updates/Start`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2002FromJSON(jsonValue));
    }

    /**
     * StartUpdate starts PMM Server update.
     */
    async startUpdate(requestParameters: StartUpdateRequest): Promise<InlineResponse2002> {
        const response = await this.startUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     * UpdateStatus returns PMM Server update status.
     */
    async updateStatusRaw(requestParameters: UpdateStatusRequest): Promise<runtime.ApiResponse<InlineResponse2003>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling updateStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/Updates/Status`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: InlineObject3ToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2003FromJSON(jsonValue));
    }

    /**
     * UpdateStatus returns PMM Server update status.
     */
    async updateStatus(requestParameters: UpdateStatusRequest): Promise<InlineResponse2003> {
        const response = await this.updateStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * Version returns PMM Server versions.
     */
    async versionRaw(requestParameters: VersionRequest): Promise<runtime.ApiResponse<InlineResponse20042>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.dummy !== undefined) {
            queryParameters['dummy'] = requestParameters.dummy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/version`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse20042FromJSON(jsonValue));
    }

    /**
     * Version returns PMM Server versions.
     */
    async version(requestParameters: VersionRequest): Promise<InlineResponse20042> {
        const response = await this.versionRaw(requestParameters);
        return await response.value();
    }

}
